#     sigma,
#     p,
#     m,
#     s,
#     R,
#     B,
#     replication,
#     error = paste(sim_result$error),
#     llik_1 = NA,
#     llik_2 = NA,
#     llik_3 = NA,
#     chain_1 = NA,
#     chain_2 = NA,
#     chain_3 = NA,
#     acc_1 = NA,
#     acc_2 = NA,
#     acc_3 = NA
#   )
# } else {
#   result <- tibble(
#     num_pert,
#     N,
#     PROB,
#     k,
#     sigma,
#     p,
#     m,
#     s,
#     R,
#     B,
#     replication,
#     error = NULL,
#   ) %>%
#     bind_cols(sim_result)
# }
if(is.null(sim_result$result)){
result <- tibble(
num_pert,
N,
PROB,
k,
sigma,
p,
m,
s,
R,
B,
replication,
error = paste(sim_result$error),
acc = NA
)
} else {
result <- tibble(
num_pert,
N,
PROB,
k,
sigma,
p,
m,
s,
R,
B,
replication,
error = NULL,
) %>%
bind_cols(sim_result)
}
return(result)
}
)
result_final <- sim_param %>%
# slice(1) %>%
# filter(k==8 & num_pert == 0.2 & N == 50 & sigma == 1 & p == 1000 & m == 1000 & R == 1 & s == 5 & B == 1 & replication == 1) %>%
# sample_n(30) %>%
# slice(c(1)) %>%
as.list() %>%
furrr::future_pmap_dfr(
# purrr::pmap_dfr(
.options = furrr::future_options(seed = TRUE),
.progress = TRUE,
.f = function( num_pert,
N,
PROB,
k,
sigma,
dim,
s,
R,
B,
replication){
chains <- 500
lam <- 1
maxiter <- 100
nvld <- 1e4
rho <- rep(0,k)
b <- rep(B, k)
r <- rep(R, k)
prob <- rep(1/k, k)
p <- m <- dim
params <- list(
chains = chains,
lam = lam,
maxiter = maxiter,
nvld = nvld,
num_pert = num_pert,
N = N,
prob = prob,
k = k,
sigma = sigma,
p = p,
rho = rho,
m = m,
s = s,
r = r,
b = b)
# print(params)
# sim_result <- safe_result(params)
sim_result <- safe_kmeans(params)
# if(is.null(sim_result$result)){
#   result <- tibble(
#     num_pert,
#     N,
#     PROB,
#     k,
#     sigma,
#     p,
#     m,
#     s,
#     R,
#     B,
#     replication,
#     error = paste(sim_result$error),
#     llik_1 = NA,
#     llik_2 = NA,
#     llik_3 = NA,
#     chain_1 = NA,
#     chain_2 = NA,
#     chain_3 = NA,
#     acc_1 = NA,
#     acc_2 = NA,
#     acc_3 = NA
#   )
# } else {
#   result <- tibble(
#     num_pert,
#     N,
#     PROB,
#     k,
#     sigma,
#     p,
#     m,
#     s,
#     R,
#     B,
#     replication,
#     error = NULL,
#   ) %>%
#     bind_cols(sim_result)
# }
if(is.null(sim_result$result)){
result <- tibble(
num_pert,
N,
PROB,
k,
sigma,
p,
m,
s,
R,
B,
replication,
error = paste(sim_result$error),
acc = NA
)
} else {
result <- tibble(
num_pert,
N,
PROB,
k,
sigma,
p,
m,
s,
R,
B,
replication,
error = NULL,
) %>%
bind_cols(sim_result)
}
return(result)
}
)
future::plan("multiprocess")
result_final <- sim_param %>%
# slice(1) %>%
# filter(k==8 & num_pert == 0.2 & N == 50 & sigma == 1 & p == 1000 & m == 1000 & R == 1 & s == 5 & B == 1 & replication == 1) %>%
# sample_n(30) %>%
# slice(c(1)) %>%
as.list() %>%
furrr::future_pmap_dfr(
# purrr::pmap_dfr(
.options = furrr::future_options(seed = TRUE),
.progress = TRUE,
.f = function( num_pert,
N,
PROB,
k,
sigma,
dim,
s,
R,
B,
replication){
chains <- 500
lam <- 1
maxiter <- 100
nvld <- 1e4
rho <- rep(0,k)
b <- rep(B, k)
r <- rep(R, k)
prob <- rep(1/k, k)
p <- m <- dim
params <- list(
chains = chains,
lam = lam,
maxiter = maxiter,
nvld = nvld,
num_pert = num_pert,
N = N,
prob = prob,
k = k,
sigma = sigma,
p = p,
rho = rho,
m = m,
s = s,
r = r,
b = b)
# print(params)
# sim_result <- safe_result(params)
sim_result <- safe_kmeans(params)
# if(is.null(sim_result$result)){
#   result <- tibble(
#     num_pert,
#     N,
#     PROB,
#     k,
#     sigma,
#     p,
#     m,
#     s,
#     R,
#     B,
#     replication,
#     error = paste(sim_result$error),
#     llik_1 = NA,
#     llik_2 = NA,
#     llik_3 = NA,
#     chain_1 = NA,
#     chain_2 = NA,
#     chain_3 = NA,
#     acc_1 = NA,
#     acc_2 = NA,
#     acc_3 = NA
#   )
# } else {
#   result <- tibble(
#     num_pert,
#     N,
#     PROB,
#     k,
#     sigma,
#     p,
#     m,
#     s,
#     R,
#     B,
#     replication,
#     error = NULL,
#   ) %>%
#     bind_cols(sim_result)
# }
if(is.null(sim_result$result)){
result <- tibble(
num_pert,
N,
PROB,
k,
sigma,
p,
m,
s,
R,
B,
replication,
error = paste(sim_result$error),
acc = NA
)
} else {
result <- tibble(
num_pert,
N,
PROB,
k,
sigma,
p,
m,
s,
R,
B,
replication,
error = NULL,
) %>%
bind_cols(sim_result)
}
return(result)
}
)
result_final
result_final %>% View()
result_final %>%
readr::write_rds("20210415_kmeans_k2.rds")
res %>% colnames()
cols <- res %>%
colnames() %>%
slice(1:11)
res %>%
colnames()
cols <- colnames(res)[1:11]
cols
slide_results <- res %>%
left_join(res_k, by = cols)
res_k <- readr::read_rds("./results/20210415_kmeans_k2.rds")
slide_results <- res %>%
left_join(res_k, by = cols)
slide_results %>% View()
slide_results <- res %>%
left_join(res_k, by = cols) %>%
select(N, p, m, s, R, "hthmix" = acc_1, "kmeans" = result)
slide_results
slide_results %>% View()
slide_results %>% filter(p == 1000, m == 1000)
slide_results %>% filter(p == 1000, m == 1000) %>% View()
slide_results <- res %>%
left_join(res_k, by = cols) %>%
filter(p == 1000, m == 1000) %>%
select(N, s, R, "hthmix" = acc_1, "kmeans" = result)
slide_results %>% View(0)
slide_results %>% View()
slide_results %>% knitr::kable()
slide_results %>%
readr::write_rds("slide_results.rds")
knitr::opts_chunk$set(echo = FALSE)
readr::read_rds("./results/20210415_slide_results.rds") %>%
knitr::kable()
readr::read_rds("G:/My Drive/Dissertation/HTH Mixture/hthmixture/results/20210415_slide_results.rds") %>%
knitr::kable()
?knitr::kable
readr::read_rds("G:/My Drive/Dissertation/HTH Mixture/hthmixture/results/20210415_slide_results.rds") %>%
knitr::kable(format = "latex")
data %>% print()
data <- readr::read_rds("G:/My Drive/Dissertation/HTH Mixture/hthmixture/results/20210415_slide_results.rds")
data %>% print()
data %>% nrow()
res
high_dim <- readr::read_rds("./results/20210205_high_dim_sarrs_sim_alex.rds")
high_dim %>% View()
high_dim %>% View()
high_dim %>%
filter(dim >= 1000)
View()
high_dim %>%
filter(dim >= 1000) %>%
View()
high_dim %>%
filter(dim >= 1000, b == 5) %>%
View()
qt(0.975, 18)
pt(0.975, 18)
n <- 200
p <- 40/n
se <- sqrt(p*(1-p)/n)
p-se*qnorm(0.975)
p+se*qnorm(0.975)
qnorm(0.975)
((qnorm(0.975)^2)*p*(1-p))/((0.02)^2)
p <- 0.25
((qnorm(0.975)^2)*p*(1-p))/((0.03)^2)
n <- 1048
p <- 0.69
n <- 1048
p <- 0.69
se <- sqrt(p*(1-p)/n)
p-se*qnorm(0.975)
p+se*qnorm(0.975)
tstat <- (p-0.79)/se
tstat
pnorm(tstat)
library(MASS)
car.data <- data.frame(Cars93$AirBags, Cars93$Type)
car.data
car.data = table(Cars93$AirBags, Cars93$Type)
print(car.data)
print(chisq.test(car.data))
data <- tibble("Yes" = c(26, 10), "No" = c(94, 110))
rownames(data) <- c("Nev", "Lop")
library(dplyr)
data <- tibble("Yes" = c(26, 10), "No" = c(94, 110))
rownames(data) <- c("Nev", "Lop")
data
data <- data.frame("Yes" = c(26, 10), "No" = c(94, 110))
rownames(data) <- c("Nev", "Lop")
data
print(chisq.test(data))
install.packages("shotGroups")
shotGroups::rMaxwell(1)
shotGroups::rMaxwell(5)
shotGroups::rMaxwell(5)
shotGroups::rMaxwell(5)
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
test
license()
library(dplyr)
library(ggplot2)
library(valse)
source("./functions/20210205_sarrs_alex.R")
# set.seed(19921124)
num_pert <- 20
chains <- 1
lam <- 1
maxiter <- 100
N <- 100
prob <- c(0.5,0.5)
k <- prob %>% length()
nvld <- 1e4
rho <- c(0,0)
sigma <- 1
p <- 200
m <- 200
s <- 5
r <- c(1,1)
b <- c(5,10)
int <- prob %>% cumsum()
rand_assign <- runif(N)
names <- paste0("c_",1:k)
if(k*s > p){print("FOR SEPARATION, VERIFY THAT K*S < P")}
# make sure k*s is less than p
clust_assign_true <- (rand_assign) %>%
purrr::map_int(.f = function(.x){
clust <- (.x <= int) %>%
which() %>%
min()
return(clust)
}) %>%
sort()
clust_assign_true_key <- clust_assign_true %>%
tibble() %>%
mutate(order = 1:N) %>%
arrange((.))
clust_assign_true_vec <- clust_assign_true_key %>%
pull(order)
n <- clust_assign_true %>%
as_tibble() %>%
group_by(value) %>%
summarize(n = n()) %>%
pull(n)
gamma_store <<- as_tibble(matrix(rep(0,k),nrow=1)) %>%
rename_if(is.numeric,~names) %>%
mutate(w_ll = 0, iter = 0)
# chain_store <- tibble(obs = 0, assign = 0, llik = 0, chain = 0)
clust_iter <<- 1
clust_min <<- 1
clust_max <<- s
data_k <- n %>%
list(r,rho,b) %>%
purrr::pmap(.f = function(.n,.r,.rho,.b){
a_rows <- clust_min:clust_max
clust_iter <<- clust_iter + 1
clust_min <<- clust_max+1
clust_max <<- clust_iter*s
sim <- sim_sarrs(.n,nvld,.n,a_rows,p,m,.r,.rho,sigma,.b)
A <- sim %>%
purrr::pluck("A")
S <- sim %>%
purrr::pluck("sig")
X <- sim %>%
purrr::pluck("X")
Y <- sim %>%
purrr::pluck("Y")
return(list(X=X,Y=Y,A=A,S=S))
})
stack_X <- data_k %>%
purrr::map_dfr(.f = function(.x){
X <- .x %>%
purrr::pluck("X")
return(as_tibble(X))
}) %>%
slice(clust_assign_true_vec) %>%
as.matrix()
stack_Y <- data_k %>%
purrr::map_dfr(.f = function(.x){
Y <- .x %>%
purrr::pluck("Y")
return(as_tibble(Y))
}) %>%
slice(clust_assign_true_vec) %>%
as.matrix()
test <- runValse(stack_X, stack_Y, verbose = TRUE)
